# 进程（一）

---

## 前言

### 冯诺依曼体系结构

> * CPU读取数据（数据+代码）都是从内存中读取，站在数据角度认为CPU不与外设直接交互，外设只和内存打交道，CPU要读取数据需要先将外设中的数据加载到内存中
> * 程序要运行必须先加载到内存中（这时候其实说这是一个进程更贴切点），这是由冯诺依曼体系结构决定

![image-20230719101428465](https://dhrs-oss.oss-cn-beijing.aliyuncs.com/img/202307301353402.png)

---

### 操作系统

> 操作系统是进行软硬件资源管理的软件
>
> 对上提供良好的运行环境，对下确保系统的稳定性
>
> **为了确保系统的稳定性，对于操作系统而言，上层所有的人都不值得信任，所以操作系统只需预留一些系统接口来供上层用户使用，不允许上层用户直接参与硬件的管理。所有的访问都必须直接贯穿系统**

**什么是管理？**

先描述再组织

#### 简单描述操作系统


![1](https://dhrs-oss.oss-cn-beijing.aliyuncs.com/img/202307301353495.png)

---

## 进程

在计算机中，我们启动一个程序本质上就是启动一个进程。

在Linux下运行一个指令，执行一个程序，其实都是在系统层面创建了一个进程。

> Linux是可以同时加载多个程序的，即Linux是可以同时存在多个进程在系统当中的

---

### Linux是如何管理进程的呢？

Linux对进程的管理可以理解为Linux为每个进程都定义了PCB（可以理解为结构体）用于进行管理。也就是先描述（创建进程结构体）再组织（管理结构体）。

> 在PCB中包含对应进程的所有属性

那这样对进程的管理就变成了对结构体PCB的增删查改

> 进程 = 对应的代码和数据 + 进程对应的PCB结构体

---

#### PCB是什么？内部属性都有哪些？

> process control block 进程控制块

> 以Linux为例，PCB中包含了：
>
> * **标示符**：描述当前对应进程的唯一标示符，用来区别其他进程
> * **状态**：任务状态、退出代码、退出信号等
> * **优先级**：用来判断和其他进程的优先级
> * **程序计数器**：程序中即将被执行的下一条指令的地址
> * **内存指针**：包括程序代码和进程相关数据的指针，还有和其他进程共享的内存块的指针
> * **上下文数据**：进程执行时处理器的寄存器中的数据
> * **I/O状态信息**：包括显示的I/O请求,分配给进程的I／ O设备和被进程使用的文件列表
> * **记账信息**：可能包括处理器时间总和，使用的时钟数总和，时间限制，记账号等
> * **其他信息** 

---

### PID&&PPID

* **PID是当前进程的ID**
* **PPID是当前进程的父进程的ID**

---

### 查看进程

> **ps**
>
> ```c
> ps ajx | grep 进程名称
> ```

> **top(类似于资源管理器)**

> **proc目录（进程以文件的形式展示出来）**
>
> proc目录中的文件是动态的，随着进程的改变而改变。
>
> 通过进入对应进程目录中可以找到cwd……
>
> cwd:当前进程的工作目录（每个进程都会有一个属性来保护自己所在的工作路径）
>
> exe：对应的可执行程序所在的路径

---

### 小练习-创建子进程并且打印父子进程id信息

> **fork()**创建子进程
>
> fork是系统调用，返回类型是pid_t，
>
> 返回值：成功：给父进程返回子进程的pid，给子进程返回0
>
> ​		失败：返回-1



> getpid：系统调用接口，用来获取进程的ID，返回类型为Pid_t
>
> getppid：系统调用接口，用来获取父进程的ID，返回类型为Pid_t
>
> ![image-20231009214216346](https://dhrs-oss.oss-cn-beijing.aliyuncs.com/img/202310092142415.png)



>  **kill指令**
>
> ```c
> kill -9 进程id
> ```
>
> 给目标进程发送9号信号相当于终止进程

---

```c

#include <unistd.h>
#include <iostream>
int main()
{
     pid_t pid = fork();//调用fork创建子进程
     if(pid == -1)//创建子进程失败返回-1
     {
         perror("fork");//打印fork失败的原因
         return -1;
     }
     if(pid != 0)//fork给父进程返回子进程的pid不为0
     {
         while(1)
         {
             printf("我是父进程:PID:%d,PPID:%d\n",getpid(),getppid());
             sleep(1);
         }
     }
     if(pid == 0)//fork给子进程返回0
     {
         while(1)
         {
            printf("我是子进程：PID:%d,PPID:%d\n",getpid(),getppid());
            sleep(1);
         }                                                                                                   
     }
    return 0;
}
```

---

![image-20231009215458689](https://dhrs-oss.oss-cn-beijing.aliyuncs.com/img/202310092154724.png)

---

## fork基本用法

* fork之后代码父子共享，但是通过判断fork的返回值来执行不同的代码（目的是为了让父子进程去执行不同的任务）

* fork为什么会有两个返回值（同一个变量怎么会同时出现不同的值）

  > fork函数是操作系统实现的
  >
  > 父子进程本是上也是多个进程，要新建一个对应的task_struct（结构体），内部属性以父进程为模板
  >
  > 在fork函数内部也会有return，在return之前操作系统要做的已经做完了，也就是在fork函数的return之前操作系统就已经建立好两个进程了，两个进程会有各自对应的返回值，而子进程内部属性以父进程为模板，数据代码和父进程公用，当子进程和父进程对同一个数据有分歧时就会产生写时拷贝（随后会细说写时拷贝）
  >
  > 所以操作
