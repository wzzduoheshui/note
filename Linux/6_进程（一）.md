# 进程（一）

---

## 前言

### 冯诺依曼体系结构

> * CPU读取数据（数据+代码）都是从内存中读取，站在数据角度认为CPU不与外设直接交互，外设只和内存打交道，CPU要读取数据需要先将外设中的数据加载到内存中
> * 程序要运行必须先加载到内存中（这时候其实说这是一个进程更贴切点），这是由冯诺依曼体系结构决定

![image-20230719101428465](https://dhrs-oss.oss-cn-beijing.aliyuncs.com/img/202307301353402.png)

---

### 操作系统

> 操作系统是进行软硬件资源管理的软件
>
> 对上提供良好的运行环境，对下确保系统的稳定性
>
> **为了确保系统的稳定性，对于操作系统而言，上层所有的人都不值得信任，所以操作系统只需预留一些系统接口来供上层用户使用，不允许上层用户直接参与硬件的管理。所有的访问都必须直接贯穿系统**

**什么是管理？**

先描述再组织

#### 简单描述操作系统


![1](https://dhrs-oss.oss-cn-beijing.aliyuncs.com/img/202307301353495.png)

---

## 进程

在计算机中，我们启动一个程序本质上就是启动一个进程。

在Linux下运行一个指令，执行一个程序，其实都是在系统层面创建了一个进程。

> Linux是可以同时加载多个程序的，即Linux是可以同时存在多个进程在系统当中的

---

### Linux是如何管理进程的呢？

Linux对进程的管理可以理解为Linux为每个进程都定义了PCB（可以理解为结构体）用于进行管理。也就是先描述（创建进程结构体）再组织（管理结构体）。

> 在PCB中包含对应进程的所有属性

那这样对进程的管理就变成了对结构体PCB的增删查改

> 进程 = 对应的代码和数据 + 进程对应的PCB结构体

---

#### PCB是什么？内部属性都有哪些？

> process control block 进程控制块

> 以Linux为例，PCB中包含了：
>
> * **标示符**：描述当前对应进程的唯一标示符，用来区别其他进程
> * **状态**：任务状态、退出代码、退出信号等
> * **优先级**：用来判断和其他进程的优先级
> * **程序计数器**：程序中即将被执行的下一条指令的地址
> * **内存指针**：包括程序代码和进程相关数据的指针，还有和其他进程共享的内存块的指针
> * **上下文数据**：进程执行时处理器的寄存器中的数据
> * **I/O状态信息**：包括显示的I/O请求,分配给进程的I／ O设备和被进程使用的文件列表
> * **记账信息**：可能包括处理器时间总和，使用的时钟数总和，时间限制，记账号等
> * **其他信息** 

---

### PID&&PPID

* **PID是当前进程的ID**
* **PPID是当前进程的父进程的ID**

---

### 查看进程

> **ps**
>
> ```c
> ps ajx | grep 进程名称
> ```

> **top(类似于资源管理器)**

> **proc目录（进程以文件的形式展示出来）**
>
> proc目录中的文件是动态的，随着进程的改变而改变。
>
> 通过进入对应进程目录中可以找到cwd……
>
> cwd:当前进程的工作目录（每个进程都会有一个属性来保护自己所在的工作路径）
>
> exe：对应的可执行程序所在的路径

---

### 小练习-创建子进程并且打印父子进程id信息

> **fork()**创建子进程
>
> fork是系统调用，返回类型是pid_t，
>
> 返回值：成功：给父进程返回子进程的pid，给子进程返回0
>
> ​		失败：返回-1



> getpid：系统调用接口，用来获取进程的ID，返回类型为Pid_t
>
> getppid：系统调用接口，用来获取父进程的ID，返回类型为Pid_t
>
> ![image-20231009214216346](https://dhrs-oss.oss-cn-beijing.aliyuncs.com/img/202310092142415.png)



>  **kill指令**
>
> ```c
> kill -9 进程id
> ```
>
> 给目标进程发送9号信号相当于终止进程

---

```c

#include <unistd.h>
#include <iostream>
int main()
{
     pid_t pid = fork();//调用fork创建子进程
     if(pid == -1)//创建子进程失败返回-1
     {
         perror("fork");//打印fork失败的原因
         return -1;
     }
     if(pid != 0)//fork给父进程返回子进程的pid不为0
     {
         while(1)
         {
             printf("我是父进程:PID:%d,PPID:%d\n",getpid(),getppid());
             sleep(1);
         }
     }
     if(pid == 0)//fork给子进程返回0
     {
         while(1)
         {
            printf("我是子进程：PID:%d,PPID:%d\n",getpid(),getppid());
            sleep(1);
         }                                                                                                   
     }
    return 0;
}
```

---

![image-20231009215458689](https://dhrs-oss.oss-cn-beijing.aliyuncs.com/img/202310092154724.png)

---

## fork基本用法

* fork之后代码父子共享，但是通过判断fork的返回值来执行不同的代码（目的是为了让父子进程去执行不同的任务）

* fork为什么会有两个返回值（同一个变量怎么会同时出现不同的值）

  > fork函数是操作系统实现的
  >
  > 父子进程本是上也是多个进程，要新建一个对应的task_struct（结构体），内部属性以父进程为模板
  >
  > 在fork函数内部也会有return，在return之前操作系统要做的已经做完了，也就是在fork函数内部的return之前操作系统就已经建立好两个进程了，两个进程会有各自对应的返回值，而子进程内部属性以父进程为模板，数据代码和父进程公用，当子进程和父进程对同一个数据有分歧时就会产生写时拷贝（随后会细说写时拷贝）
  >
  > 操作系统和CPU运行某一进程，本质就是从进程队列中选择一个task_struct来执行，进程的调度就变成了task_struct队列中选择进程的过程。
  >
  > 所以fork内部，父子进程就已经产生了，fork的两个返回值也是给了不同的进程
  
  ![image-20231010202310649](https://dhrs-oss.oss-cn-beijing.aliyuncs.com/img/202310102023721.png)
  
* 父子进程被创建后哪个先运行？

  > 不一定，这个与CPU有关，与操作系统的调度器有关

* fork之后再fork会发生什么？

  > ```c
  > #include <stdio.h>
  > #include <unistd.h>
  > 
  > int main()
  > {
  >     pid_t pid = fork();
  >     if(pid == 0)
  >     {
  >         printf("我是子进程:pid:%d,ppid:%d\n",getpid(),getppid());
  >         pid_t p = fork();
  >         if(p == 0)
  >         {
  >             printf("我是子进程的子进程：pid:%d,ppid:%d\n",getpid(),getppid());
  >         }
  >         return 0;
  >     }
  >     if(pid > 0)
  >     {
  >         printf("我是父进程:pid:%d,ppid:%d\n",getpid(),getppid());
  >         sleep(1);//这里睡眠的目的是为了防止父进程过早的退出造成孤儿进程的产生
  >     }
  >     return 0;
  > }
  > ```
  >
  > ps：这里为了简便并没有对fork创建进程失败进行判断
  >
  > ![fork中套fork运行截图](https://dhrs-oss.oss-cn-beijing.aliyuncs.com/img/202310102132773.png)

---

## 监控命令行脚本

```c
while :;do ps ajx | head -1 && ps ajx | grep test | grep -v grep;sleep 1;echo "---------------";done
```

---

## 进程状态

* **新建**：字面意思，进程pcb刚被建立，没有进入队列（实际中并没有这种状态）
* **运行**：task_struct结构体在运行队列中排队即被称为运行态
* **阻塞**：等待非CPU资源就绪
* **挂起**：当内存不足的时候，操作系统适当的置换进程的代码和数据到磁盘上，则该进程的状态就是挂起
* **退出**：字面意思

> **进程队列**
>
> * 系统中一定存在各种资源
> * 系统中不止存在一种队列
>
> > 例：
> >
> > ![image-20231010214503099](https://dhrs-oss.oss-cn-beijing.aliyuncs.com/img/202310102145128.png)
> >
> > A正在被CPU执行，但需要申请磁盘资源，此时磁盘正忙。
> >
> > 则A转入磁盘的等待队列（阻塞状态），待磁盘允许A访问时，A再转到CPU来写入磁盘。
> >
> > 其中，转入磁盘队列就是阻塞队列
>
> ---
>
> **挂起状态**
>
> ![image-20231010215059829](https://dhrs-oss.oss-cn-beijing.aliyuncs.com/img/202310102150862.png)
>
> 当内存快不足时，操作系统会将长时间不执行的进程换出到磁盘的swap分区（这个状态就是挂起状态）
>
> 换出的是进程的代码和数据，进程的pcd依旧在内存里面

---

## Linux进程状态

### 运行状态（R）

