@[TOC]()

# 类和对象

---

## 面向对象和面向过程

> 面向对象相当于是关注对象之间的关系，比如在点餐系统中更加注意商家、用户、骑手之间的联系
>
> 面向过程相当于是更加注意流程函数的实现，比如点餐系统中更加注意点餐、送餐、选餐等等流程函数的实现

常见的一些语言：

C：面向过程

C++：基于面向对象的语言

Java：纯面向对象的语言

---

## C++中的类

---

### 访问限定符

C++中对于类的访问限定符存在以下三类：private、public、private。

C++是基于面向对象的语言，C++兼容C语言中的`struct`语法，同时将`struct`进行了升级（升级为类）

即使这样C++对于`struct类`和`class类`还是有一定的区别的，

> `class`默认类的访问限定符为`private`，`struct`默认访问限定符为`public`

所以我们推荐使用`class`

---

### 类的定义

类的定义：

* 在类中定义：在类中的定义，可能会被当做内联函数处理。

* 分离定义：分离的定义

面向对象的三大特征：封装、继承、多态

> 封装的本质是一种管理

---

这里就想到了域，

> 关于域主要影响到的是访问权限范围，

那什么影响到的是声明周期呢？

> 生命周期要看存放的区域
>
> 也就是存储位置，这里会影响到生命周期

---

### 类的实例化

#### 什么是类的实例化？

> 首先我们应该先知道什么是类？类我们可以理解为建筑物的图纸，有了图纸就一定有房子吗？也就是说有了类就一定有对象吗？不一定，所以我们把通过类定义对象时来开辟空间的过程叫做类的实例化。

#### 类成员变量是声明还是定义呢？

> 声明（开辟空间是定义，否则就是声明）

#### sizeof（类）？

> sizeof在计算类型大小的时候是通过类型大小来计算的，所以并不需要一定要实例化才可以计算所占空间的大小

---

## 类和对象的存储方式

首先先从汇编去看

```cpp
class student
{
public:
	void print()
	{
		cout << "name:" << _name << endl;
		cout << "age:" << _age << endl;
		cout << "_num" << _num << endl;
	}
private:
	char _name[20];
	int _age;
	int _num;
};

int main()
{
	student s1;
	s1.print();
	student s2;
	s2.print();
}
```

![类和对象的存储方式](https://dhrs-oss.oss-cn-beijing.aliyuncs.com/img/202307292118553.png)

**这里可以看到调用的函数是同一个**

也就是我们可以这么理解对象和函数并无关联

![类和对象的存储方式2](https://dhrs-oss.oss-cn-beijing.aliyuncs.com/img/202307292134276.png)

也就是说编译器在编译链接时就去根据函数名称去公共代码区找到对应函数的地址

---

> 那么以下函数的调用能否正常运行
>
> ```cpp
> A* ptr = nullptr;
> ptr->func();
> //func函数内没有使用类成员变量
> ```
>
> 结论是可以正常运行的，因为类成员变量和类成员函数的存储方式使得对象即使未实例化也可以调用类成员函数

---

这里值得注意的是**类成员变量依旧遵循内存对齐规则**。

#### 关于类的大小（占位）

> **有成员变量：遵循内存对齐规则**
>
> **无成员变量：** （这里会开辟1byte的占位，不存储实际数据，仅标示对象存在）
>
> * **有成员函数**：1byte
> * **无成员函数**：1byte

---

## this指针

在调用类成员函数的时候编译器会在第一个变量前加上this（可以在函数内部使用，但不能显示的传递和接收）

this指针存在哪里？

栈区，因为this指针属于一个形参（可能会被优化到寄存器，目的是为了提高this指针的访问效率，这个具体是否优化取决于编译器。）
