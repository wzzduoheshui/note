# 3_C++基础：：函数重载

---

## 函数重载有什么意义吗？

函数重载可以帮助我们简化函数的使用，帮助我们简化代码的编写。可以大大提高代码的可读性和灵活性。函数重载还可以使代码更加模块化，更容易复用，减少代码冗余，提高代码的可维护性和可扩展性。

> 函数重载是指在同一作用域内，可以定义多个同名的函数，但它们的形参列表必须不同（参数个数、参数类型和参数顺序等至少有一个不同）。在调用同名函数时，编译器会根据实参的类型和数量，自动匹配调用对应的重载函数。函数重载可以提高代码的可读性和复用性。
>
> 例如：C++中的cout就是一个函数重载，便于我们使用。

---

## 函数重载要求：

在统一作用域，包括命名空间在内，函数的形参数量不同、类型不同、顺序（类型顺序）不同。

* 形参数量不同

```cpp
//形参数量不同
int add(int a, int b, int c)
{
	return a + b + c;
}
int add(int a, int b)
{
	return a + b;
}
int main()
{
	cout << add(1, 2) << endl;
	cout << add(1, 2, 3) << endl;
	return 0;
}
```

* 形参类型不同

```cpp
//形参类型不同
int add(int a, int b)
{
	return a + b;
}
double add(double a, double b)
{
	return a + b;
}
int main()
{
	cout << add(1, 2) << endl;
	cout << add(1.1, 2.2) << endl;
	return 0;
}
```

*  形参类型顺序不同

```cpp 
//形参类型顺序不同
void print(int a, double b)
{
    cout << "printid" << endl;
}
void print(double a, int b)
{
    cout << "printdi" << endl;
}
int main()
{
    print(1, 1.1);
    print(1.1, 1);
    return 0;
}
```

> ps：返回值不同的函数不构成函数重载，无法进行区分

---

## 为什么C++支持函数重载？

首先我们应该先明白C++或者c文件到到可执行文件的过程

> 预处理：展开头文件、宏替换、条件编译、去掉注释（生成.i文件）
>
> 编译：语法检查、生成对应的汇编代码（生成.s文件）
>
> 汇编：把汇编代码转换为二进制机器码（可重定向二进制目标文件）（生成.o文件）
>
> 链接：链接器会将目标代码文件与库文件（libraries）进行链接，并生成可执行文件。.o/.obj目标文件合并在一起形成可执行程序

这里我们用Linux来看

对.c文件和.cpp文件分别进行处理生成 .o文件

 ```cpp
 //c++文件
 g++ -c hello2.cpp -o hello2.o
     
 //c文件
 gcc -c hello.c -o hello.c
 ```

分别查看对应的符号表

```cpp
//c文件
objdump -t hello2.o
//c文件
objdump -t hello.o
```

 最后显示出来的结果

```cpp
//c++文件
0000000000000000 g     F .text	0000000000000014 _Z3addii
0000000000000014 g     F .text	000000000000002c _Z3adddd
//c文件
0000000000000000 g     F .text	0000000000000015 func
```

> 对于这里C++函数的修饰规则
>
> _Z是前缀，3是函数名中包含的字符个数，add是函数名，ii/dd是形参类型的首字母

由此可知：

* c语言中的函数符号表只是将函数名称直接用于符号表进行区分函数，并不进行过多处理
* C++语言中函数的符号表会将函数名称，形参类型等综合起来进行修饰形成符号表，用来区分不同的函数

所以C++可以更好的支持函数重载，编译器也可以更好的完成相同函数名称的函数的区分，

> ps：这也就是之前说的函数的返回类型并不能作为函数重载区分的依据之一

---

总结：

* 函数重载要是同一作用域包括命名空间在内的函数形参数量不同、形参的类型不同，形参不同类型的排列顺序不同来区分函数名称相同的不同函数
* C++能进行函数重载的本质是因为C++较C语言来说C++的函数名称的修饰不同
